<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: {text: 'Environment Reward vs Value Estimate Over Time'},
      xaxis: { ...basePlotLayout.xaxis, title: {text: 'Time Step'} },
      yaxis: { ...basePlotLayout.yaxis, title: {text: 'Value'} },
    },
    plot: null,
    yRange: [Infinity, -Infinity],
    envRewards: [],
    valueEstimates: [],
    shapesAndAnnotationsByStep: {},
    previousStep: 0,
  }"
  x-init="
    envRewards = parsedData.environment_rewards || [];
    valueEstimates = parsedData.value_estimates || [];
    const timeSteps = Array.from({length: maxSteps}, (_, i) => i);

    envRewards.forEach((episodeRewards, idx) => {
      if (!episodeRewards || episodeRewards.length === 0) return;
      const ep = envRewards.length > 1 ? `episode ${episodeIds[idx]} - ` : '';
      data.push({
        x: timeSteps.slice(0, episodeRewards.length),
        y: episodeRewards,
        type: 'scatter',
        mode: 'lines',
        name: `${ep}reward`,
      });
      const currentRange = [Math.min(...episodeRewards), Math.max(...episodeRewards)];
      yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
    });

    valueEstimates.forEach((episodeValues, idx) => {
      if (!episodeValues) return;
      const ep = valueEstimates.length > 1 ? `episode ${episodeIds[idx]} - ` : '';
      Object.entries(episodeValues).forEach(([agent, values]) => {
        if (!values || values.length === 0) return;
        data.push({
          x: timeSteps.slice(0, values.length),
          y: values,
          type: 'scatter',
          mode: 'lines+markers',
          name: `${ep}${agent} (est)`,
        });
        const currentRange = [Math.min(...values), Math.max(...values)];
        yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
      });
    });

    // Create all steps and annotations at once
    timeSteps.forEach((ts) => {
      if (!shapesAndAnnotationsByStep[ts]) {
        shapesAndAnnotationsByStep[ts] = [];
      }

      // Add vertical line shape for this step
      shapesAndAnnotationsByStep[ts].push({
        shape: {
          type: 'line',
          x0: ts,
          x1: ts,
          y0: yRange[0],
          y1: yRange[1],
          line: {
            color: 'red',
            width: 2,
            dash: 'dot'
          },
        }
      });

      // Add annotations for value estimates at this step
      valueEstimates.forEach((episodeValues, idx) => {
        if (!episodeValues) return;

        Object.entries(episodeValues).forEach(([agent, values], agentIdx) => {
          if (values && values[ts] !== undefined) {
            shapesAndAnnotationsByStep[ts].push({
              annotation: {
                x: ts,
                y: values[ts],
                text: values[ts].toFixed(2),
                font: {
                  color: $store.categoricalColors[(agentIdx + 1) % $store.categoricalColors.length],
                },
              }
            });
          }
        });
      });

      // Add annotations for environment rewards at this step
      envRewards.forEach((episodeRewards, idx) => {
        if (!episodeRewards || episodeRewards.length === 0) return;

        if (episodeRewards[ts] !== undefined) {
          shapesAndAnnotationsByStep[ts].push({
            annotation: {
              x: ts,
              y: episodeRewards[ts],
              text: episodeRewards[ts].toFixed(2),
              font: {
                color: $store.categoricalColors[idx % $store.categoricalColors.length],
              },
            }
          });
        }
      });
    });

    plot = Plotly.react($refs.valueEstimatePlot, data, {
      ...layout,
      shapes: shapesAndAnnotationsByStep[0].map(({shape}) => shape).filter(Boolean),
      annotations: shapesAndAnnotationsByStep[0].map(({annotation}) => annotation).filter(Boolean),
    }, basePlotConfig);

    // Watch for changes in visualization options
    $watch('$store.visOptions', () => {
      $nextTick(() => {
        Plotly.relayout(
          $refs.valueEstimatePlot,
          {
            autosize: true,
            showlegend: $store.visOptions.visible.includes('plotLegends'),
            legend: legendLayout(),
          });
      });
    });
  "
  x-effect="
    if (plot) {
      // Update the plot with visibility changes
      Plotly.relayout($refs.valueEstimatePlot, {
        shapes: shapesAndAnnotationsByStep[currentStep].map(({shape}) => shape).filter(Boolean),
        annotations: shapesAndAnnotationsByStep[currentStep].map(({annotation}) => annotation).filter(Boolean),
        ...basePlotStyling()
      });

      // Update previous step
      previousStep = currentStep;
    }
  "
  class="w-full"
>
  <div x-ref="valueEstimatePlot"></div>
</div>
