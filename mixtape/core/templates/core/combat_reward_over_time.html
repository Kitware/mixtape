<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: { text: 'Combat Reward Over Time' },
      xaxis: { ...basePlotLayout.xaxis, title: { text: 'Step' } },
      yaxis: { ...basePlotLayout.yaxis, title: { text: 'Cumulative Reward' } },
    },
    plot: null,
    yRange: [Infinity, -Infinity],
    unitCombatRewards: parsedData?.unit_combat_rewards,
    shapesAndAnnotationsByStep: {},
    previousStep: 0,
    ep: '',
  }"
  x-init="
    const decomposedRewards = parsedData.decomposed_rewards || [];
    const unitCombatRewards = parsedData.unit_combat_rewards || [];

    if (!decomposedRewards || !unitCombatRewards) return;

    const timeSteps = Array.from({length: maxSteps}, (_, i) => i);
    getPrefix = (idx) => {
      if (decomposedRewards.length > 1) {
        return `episode ${episodeIds[idx]} - `;
      }
      return '';
    };

    decomposedRewards.forEach((agentRewards, idx) => {
      if (!agentRewards || !agentRewards.combat || agentRewards.combat.length === 0) {
        return;
      }
      data.push({
        name: `${getPrefix(idx)}agent_0`,
        x: timeSteps,
        y: agentRewards.combat,
        type: 'scatter',
        mode: 'lines',
        line: { dash: 'solid' }
      });

      // Update yRange for agent rewards
      const currentRange = [Math.min(...agentRewards.combat), Math.max(...agentRewards.combat)];
      yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
    });

    unitCombatRewards.forEach((unitRewards, idx) => {
      if (!unitRewards) return;

      const ep = unitCombatRewards.length > 1 ? `episode ${episodeIds[idx]} - ` : '';

      Object.entries(unitRewards).forEach(([unit, rewards], index) => {
        if (rewards && rewards.length > 0) {
          data.push({
            name: `${ep}${unit}`,
            x: timeSteps.slice(0, rewards.length),
            y: rewards,
            type: 'scatter',
            mode: 'lines',
            line: {
              dash: 'dashdot',
            }
          });

          const currentRange = [Math.min(...rewards), Math.max(...rewards)];
          yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
        }
      });
    });

    // Set default yRange if no data was found
    if (yRange[0] === Infinity || yRange[1] === -Infinity) {
      yRange = [0, 1];
    }

    // Create all steps and annotations at once only if we have data
    if (data.length > 0) {
      timeSteps.forEach((ts) => {
        if (!shapesAndAnnotationsByStep[ts]) {
          shapesAndAnnotationsByStep[ts] = [];
        }

        // Add vertical line shape for this step
        shapesAndAnnotationsByStep[ts].push({
          shapes: {
            type: 'line',
            x0: ts,
            x1: ts,
            y0: yRange[0],
            y1: yRange[1],
            line: {
              color: 'red',
              width: 2,
              dash: 'dot'
            },
          }
        });

        // Add annotations for unit rewards at this step
        unitCombatRewards.forEach((unitRewards, idx) => {
          if (!unitRewards) return;

          Object.keys(unitRewards).forEach((unit, unitIdx) => {
            if (unitRewards[unit] && unitRewards[unit][ts] !== undefined) {
              shapesAndAnnotationsByStep[ts].push({
                annotations: {
                  x: ts,
                  y: unitRewards[unit][ts],
                  text: unitRewards[unit][ts].toFixed(2),
                  bgcolor: 'rgba(0, 0, 0, 0.5)',
                  arrowcolor: $store.categoricalColors[(unitIdx + 1) % $store.categoricalColors.length],
                  font: {
                    color: $store.categoricalColors[(unitIdx + 1) % $store.categoricalColors.length],
                  },
                }
              });
            }
          });
        });

        // Add annotations for agent rewards at this step
        decomposedRewards.forEach((agentRewards, idx) => {
          if (!agentRewards || !agentRewards.combat || agentRewards.combat.length === 0) return;

          if (agentRewards.combat[ts] !== undefined) {
            shapesAndAnnotationsByStep[ts].push({
              annotations: {
                x: ts,
                y: agentRewards.combat[ts],
                text: agentRewards.combat[ts].toFixed(2),
                bgcolor: 'rgba(0, 0, 0, 0.5)',
                arrowcolor: $store.categoricalColors[idx % $store.categoricalColors.length],
                font: {
                  color: $store.categoricalColors[idx % $store.categoricalColors.length],
                },
              }
            });
          }
        });
      });
    }

    plot = Plotly.react($refs.combatRewardPlot, data, {
      ...layout,
      shapes: shapesAndAnnotationsByStep[0]?.filter(item => item.shapes).map(item => item.shapes) || [],
      annotations: shapesAndAnnotationsByStep[0]?.filter(item => item.annotations).map(item => item.annotations) || [],
    }, basePlotConfig);
  "
  x-effect="
    if (plot) {
      Plotly.relayout($refs.combatRewardPlot, {
        shapes: shapesAndAnnotationsByStep[currentStep]?.filter(item => item.shapes).map(item => item.shapes) || [],
        annotations: shapesAndAnnotationsByStep[currentStep]?.filter(item => item.annotations).map(item => item.annotations) || [],
        ...basePlotStyling()
      });

      // Update previous step
      previousStep = currentStep;
    }
  "
  class="w-full"
>
  <div x-ref="combatRewardPlot"></div>
</div>
