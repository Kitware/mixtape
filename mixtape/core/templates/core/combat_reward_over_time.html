<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: { text: 'Combat Reward Over Time' },
      xaxis: { ...basePlotLayout.xaxis, title: { text: 'Step' } },
      yaxis: { ...basePlotLayout.yaxis, title: { text: 'Cumulative Reward' } },
    },
    plot: null,
    yRange: [Infinity, -Infinity],
    unitCombatRewards: parsedData?.unit_combat_rewards,
    shapesAndAnnotationsByStep: {},
    previousStep: 0,
    ep: '',
  }"
  x-init="
    if (!decomposedRewards || !unitCombatRewards) return;

    const timeSteps = Array.from({length: maxSteps}, (_, i) => i);
    getPrefix = (idx) => {
      if (decomposedRewards.length > 1) {
        return `episode ${episodeIds[idx]} - agent_${idx}`;
      }
      return '';
    };

    decomposedRewards.forEach((agentRewards, idx) => {
      if (!agentRewards.length > 0 && !agentRewards?.combat) {
        return;
      }
      data.push({
        name: `${getPrefix(idx)}${uniqueAgents[idx]}`,
        x: timeSteps,
        y: agentRewards.combat,
        type: 'scatter',
        mode: 'lines',
      });
    });

    unitCombatRewards.forEach((unitRewards, idx) => {
      Object.entries(unitRewards).forEach(([unit, rewards], index) => {
        if (rewards && rewards.length > 0) {
          data.push({
            name: `${getPrefix(idx)}${unit}`,
            x: timeSteps.slice(0, rewards.length),
            y: rewards,
            type: 'scatter',
            mode: 'lines',
            line: {
              dash: 'dashdot',
            }
          });
        }
        const currentRange = [Math.min(...rewards), Math.max(...rewards)];
        yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
      });
    });

    // Create all steps and annotations at once
    const decompLen = decomposedRewards.length + 1;
    timeSteps.forEach((ts) => {
      if (!shapesAndAnnotationsByStep[ts]) {
        shapesAndAnnotationsByStep[ts] = [];
      }
      const annotations = decomposedRewards.map((agentRewards, idx) => {
        const colorIdx = (idx + 1) * (decompLen + decompLen);
        Object.values(unitCombatRewards[idx]).map((unitRewards, unitIdx) => {
          const unitColorIdx = (unitIdx + 1) + colorIdx;
          shapesAndAnnotationsByStep[ts].push({
            annotations: {
              x: ts,
              y: unitRewards[ts],
              text: unitRewards[ts].toFixed(2),
              font: {
                color: $store.categoricalColors[(unitIdx + 1) % $store.categoricalColors.length - 1],
              },
            }
          });
        });
        shapesAndAnnotationsByStep[ts].push({
          annotations: {
            x: ts,
            y: agentRewards.combat[ts],
            text: agentRewards.combat[ts].toFixed(2),
            font: {
              color: $store.categoricalColors[(idx + 1) % $store.categoricalColors.length - 1],
            },
          }
        });
      });
      shapesAndAnnotationsByStep[ts].push({
        shapes: {
          type: 'line',
          x0: ts,
          x1: ts,
          y0: yRange[0],
          y1: yRange[1],
          line: {
            color: 'red',
            width: 2,
            dash: 'dot'
          },
        }
      });
    });

    plot = Plotly.newPlot($refs.combatRewardPlot, data, {
      ...layout,
      shapes: shapesAndAnnotationsByStep[0].map(({shapes}) => shapes),
      annotations: shapesAndAnnotationsByStep[0].map(({annotations}) => annotations),
    }, basePlotConfig);

    // Watch for changes in visualization options
    $watch('$store.visOptions', () => {
      $nextTick(() => {
        Plotly.relayout(
          $refs.combatRewardPlot,
          {
            autosize: true,
            showlegend: $store.visOptions.visible.includes('plotLegends'),
            legend: legendLayout(),
          });
      });
    });
  "
  x-effect="
    if (plot) {
      // Hide the previous step shapes and annotation
      if (shapesAndAnnotationsByStep[previousStep]) {
        shapesAndAnnotationsByStep[previousStep].forEach(({shapes, annotations}) => {
          if (shapes) shapes.visible = false;
          if (annotations) annotations.visible = false;
        });
      }

      // Show the current step shapes and annotation
      if (shapesAndAnnotationsByStep[currentStep]) {
        shapesAndAnnotationsByStep[currentStep].forEach(({shapes, annotations}) => {
          if (shapes) shapes.visible = true;
          if (annotations) annotations.visible = true;
        });
      }
      Plotly.relayout($refs.combatRewardPlot, {
        shapes: shapesAndAnnotationsByStep[currentStep].map(({shapes}) => shapes),
        annotations: shapesAndAnnotationsByStep[currentStep].map(({annotations}) => annotations),
        ...basePlotStyling()
      });

      // Update previous step
      previousStep = currentStep;
    }
  "
  class="w-full"
>
  <div x-ref="combatRewardPlot"></div>
</div>
