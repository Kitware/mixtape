<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: { text: 'Predicted vs Actual Rewards Over Time' },
      xaxis: { ...basePlotLayout.xaxis, title: { text: 'Step' } },
      yaxis: { ...basePlotLayout.yaxis, title: { text: 'Reward' } },
    },
    plot: null,
    yRange: [Infinity, -Infinity],
    totalRewards: Array.isArray(totalRewards) ? totalRewards[0] : totalRewards,
    predictedRewards: Array.isArray(predictedRewards) ? predictedRewards[0] : predictedRewards,
  }"
  x-init="
    // Add actual rewards
    Object.entries(totalRewards).forEach(([entity, rewards]) => {
      if (rewards && rewards.length) {
        const cumulative = rewards.reduce((acc, r) => {
          acc.push((acc[acc.length-1] || 0) + r);
          return acc;
        }, []);
        data.push({
          x: Array.from({length: cumulative.length}, (_, i) => i),
          y: cumulative,
          type: 'scatter',
          mode: 'lines',
          name: `${entity} (Actual)`,
          line: {
            dash: entity.startsWith('unit') ? 'dashdot' : 'solid',
          }
        });
        const currentRange = [Math.min(...cumulative), Math.max(...cumulative)];
        yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
      }
    });

    // Add predicted rewards
    if (predictedRewards) {
      Object.entries(predictedRewards).forEach(([entity, preds]) => {
        if (preds && preds.length) {
          const cumulative = preds.reduce((acc, p) => {
            const val = p && p[0] ? p[0] : 0;
            acc.push((acc[acc.length-1] || 0) + val);
            return acc;
          }, []);
          data.push({
            x: Array.from({length: cumulative.length}, (_, i) => i),
            y: cumulative,
            type: 'scatter',
            mode: 'lines',
            name: `${entity} (Predicted)`,
            line: {
              dash: entity.startsWith('unit') ? 'dashdot' : 'solid',
            }
          });
          const currentRange = [Math.min(...cumulative), Math.max(...cumulative)];
          yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
        }
      });
    }

    data.push({
      x: [currentStep, currentStep],
      y: yRange,
      type: 'scatter',
      mode: 'lines',
      line: {
        color: 'red',
        width: 2,
        dash: 'dot'
      },
      name: 'Current Step',
    });
    plot = Plotly.newPlot($refs.predVsActual, data, layout, basePlotConfig);
    $watch('$store.visOptions', () => {
      $nextTick(() => {
        Plotly.relayout(
          $refs.predVsActual,
          {
            autosize: true,
            showlegend: $store.visOptions.includes('plotLegends')
          });
      });
    });
  "
  x-effect="
    if (plot) {
      data[data.length - 1].x = [currentStep, currentStep];
      const annotations = data.slice(0, -1).map((d) => {
        return {
          x: currentStep,
          y: d.y[currentStep],
          text: d.y[currentStep].toFixed(2),
        }
      });
      Plotly.update($refs.predVsActual, data, {
        annotations: annotations,
        ...basePlotStyling(),
      });
    }
  "
  class="w-full"
>
  <div x-ref="predVsActual"></div>
</div>
