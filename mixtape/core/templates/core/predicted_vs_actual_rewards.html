<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: { text: 'Predicted vs Actual Rewards Over Time' },
      xaxis: { ...basePlotLayout.xaxis, title: { text: 'Step' } },
      yaxis: { ...basePlotLayout.yaxis, title: { text: 'Reward' } },
    },
    plot: null,
    yRange: [Infinity, -Infinity],
    totalRewards: totalRewards || [],
    predictedRewards: predictedRewards || [],
    shapesAndAnnotationsByStep: {},
    previousStep: 0,
  }"
  x-init="
    // Add actual rewards
    totalRewards.forEach((episodeRewards, idx) => {
      if (!episodeRewards) return;

      const ep = totalRewards.length > 1 ? `episode ${episodeIds[idx]} - ` : '';

      Object.entries(episodeRewards).forEach(([entity, rewards]) => {
        if (rewards && rewards.length) {
          const cumulative = rewards.reduce((acc, r) => {
            acc.push((acc[acc.length-1] || 0) + r);
            return acc;
          }, []);
          data.push({
            x: Array.from({length: cumulative.length}, (_, i) => i),
            y: cumulative,
            type: 'scatter',
            mode: 'lines',
            name: `${ep}${entity} (Actual)`,
            line: {
              dash: entity.startsWith('unit') ? 'dashdot' : 'solid',
            }
          });
          const currentRange = [Math.min(...cumulative), Math.max(...cumulative)];
          yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
        }
      });
    });

    // Add predicted rewards
    predictedRewards.forEach((episodePredictions, idx) => {
      if (!episodePredictions) return;

      const ep = predictedRewards.length > 1 ? `episode ${episodeIds[idx]} - ` : '';

      Object.entries(episodePredictions).forEach(([entity, preds]) => {
        if (preds && preds.length) {
          const cumulative = preds.reduce((acc, p) => {
            const val = p && p[0] ? p[0] : 0;
            acc.push((acc[acc.length-1] || 0) + val);
            return acc;
          }, []);
          data.push({
            x: Array.from({length: cumulative.length}, (_, i) => i),
            y: cumulative,
            type: 'scatter',
            mode: 'lines',
            name: `${ep}${entity} (Predicted)`,
            line: {
              dash: entity.startsWith('unit') ? 'dashdot' : 'solid',
            }
          });
          const currentRange = [Math.min(...cumulative), Math.max(...cumulative)];
          yRange = [Math.min(yRange[0], currentRange[0]), Math.max(yRange[1], currentRange[1])];
        }
      });
    });

    // Create all steps and annotations at once
    const timeSteps = Array.from({length: maxSteps}, (_, i) => i);
    timeSteps.forEach((ts) => {
      if (!shapesAndAnnotationsByStep[ts]) {
        shapesAndAnnotationsByStep[ts] = [];
      }

      // Add vertical line shape for this step
      shapesAndAnnotationsByStep[ts].push({
        shape: {
          type: 'line',
          x0: ts,
          x1: ts,
          y0: yRange[0],
          y1: yRange[1],
          line: {
            color: 'red',
            width: 2,
            dash: 'dot'
          },
        }
      });

      // Add annotations for each data series at this step
      data.forEach((series, seriesIdx) => {
        if (series.y && series.y[ts] !== undefined) {
          shapesAndAnnotationsByStep[ts].push({
            annotation: {
              x: ts,
              y: series.y[ts],
              text: series.y[ts].toFixed(2),
              bgcolor: 'rgba(0, 0, 0, 0.5)',
              arrowcolor: $store.categoricalColors[seriesIdx % $store.categoricalColors.length],
              font: {
                color: $store.categoricalColors[seriesIdx % $store.categoricalColors.length],
              },
            }
          });
        }
      });
    });

    plot = Plotly.react($refs.predVsActual, data, {
      ...layout,
      shapes: shapesAndAnnotationsByStep[0].map(({shape}) => shape).filter(Boolean),
      annotations: shapesAndAnnotationsByStep[0].map(({annotation}) => annotation).filter(Boolean),
    }, basePlotConfig);

    $watch('$store.visOptions', () => {
      $nextTick(() => {
        Plotly.relayout(
          $refs.predVsActual,
          {
            autosize: true,
            showlegend: $store.visOptions.visible.includes('plotLegends'),
            legend: legendLayout(),
          });
      });
    });
  "
  x-effect="
    if (plot) {
      // Update the plot with visibility changes
      Plotly.relayout($refs.predVsActual, {
        shapes: shapesAndAnnotationsByStep[currentStep].map(({shape}) => shape).filter(Boolean),
        annotations: shapesAndAnnotationsByStep[currentStep].map(({annotation}) => annotation).filter(Boolean),
        ...basePlotStyling()
      });

      // Update previous step
      previousStep = currentStep;
    }
  "
  class="w-full"
>
  <div x-ref="predVsActual"></div>
</div>
