<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: { text: 'Friendly Health Over Time' },
      xaxis: { ...basePlotLayout.xaxis, title: { text: 'Step' } },
      yaxis: { ...basePlotLayout.yaxis, title: { text: 'Health' } },
    },
    plot: null,
    yRange: [Infinity, -Infinity],
    healthData: [],
    shapesAndAnnotationsByStep: {},
    previousStep: 0,
  }"
  x-init="
    healthData = parsedData.friendly_health_data || [];
    const timeSteps = Array.from({length: maxSteps}, (_, i) => i);
    healthData.forEach((episodeData, idx) => {
      if (!episodeData) return;
      const ep = healthData.length > 1 ? `episode ${episodeIds[idx]} - ` : '';
      Object.keys(episodeData).forEach(entity => {
        const healthValues = episodeData[entity];
        if (!healthValues || healthValues.length === 0) return;
        const xValues = Array.from({length: healthValues.length}, (_, i) => i);
        data.push({
          name: `${ep}${entity}`,
          x: xValues,
          y: healthValues,
          type: 'scatter',
          mode: 'lines',
          line: {
            dash: entity.toLowerCase().startsWith('agent') ? 'solid' : 'dashdot',
          },
          connectgaps: true,
        });
        const currentYRange = [Math.min(...healthValues), Math.max(...healthValues)];
        yRange = [Math.min(yRange[0], currentYRange[0]), Math.max(yRange[1], currentYRange[1])];
      });
    });
    // Create all steps and annotations at once
    timeSteps.forEach((ts) => {
      if (!shapesAndAnnotationsByStep[ts]) {
        shapesAndAnnotationsByStep[ts] = [];
      }
      // Add vertical line shape for this step
      shapesAndAnnotationsByStep[ts].push({
        shapes: {
          type: 'line',
          x0: ts,
          x1: ts,
          y0: yRange[0],
          y1: yRange[1],
          line: {
            color: 'red',
            width: 2,
            dash: 'dot'
          }
        }
      });
      // Add annotations for each entity at this step
      healthData.forEach((episodeData, idx) => {
        if (!episodeData) return;
        Object.keys(episodeData).forEach((entity, entityIdx) => {
          if (episodeData[entity] && episodeData[entity][ts] !== undefined) {
            shapesAndAnnotationsByStep[ts].push({
              annotations: {
                x: ts,
                y: episodeData[entity][ts],
                text: episodeData[entity][ts].toFixed(2),
                bgcolor: 'rgba(0, 0, 0, 0.5)',
                arrowcolor: $store.categoricalColors[entityIdx % $store.categoricalColors.length],
                font: {
                  color: $store.categoricalColors[entityIdx % $store.categoricalColors.length],
                }
              }
            });
          }
        });
      });
    });
    plot = Plotly.react($refs.friendlyHealthPlot, data, {
      ...layout,
      shapes: shapesAndAnnotationsByStep[0]?.filter(item => item.shapes).map(item => item.shapes) || [],
      annotations: shapesAndAnnotationsByStep[0]?.filter(item => item.annotations).map(item => item.annotations) || [],
    }, basePlotConfig);

    $watch('$store.visOptions', () => {
      $nextTick(() => {
        Plotly.relayout(
          $refs.friendlyHealthPlot,
          {
            autosize: true,
            showlegend: $store.visOptions.visible.includes('plotLegends'),
            legend: legendLayout(),
          })
      });
    })
  "
  x-effect="
    if (plot) {
      // Hide the previous step shapes and annotations
      if (shapesAndAnnotationsByStep[previousStep]) {
        shapesAndAnnotationsByStep[previousStep].forEach(item => {
          if (item.shapes) item.shapes.visible = false;
          if (item.annotations) item.annotations.visible = false;
        });
      }

      // Show the current step shapes and annotations
      if (shapesAndAnnotationsByStep[currentStep]) {
        shapesAndAnnotationsByStep[currentStep].forEach(item => {
          if (item.shapes) item.shapes.visible = true;
          if (item.annotations) item.annotations.visible = true;
        });
      }

      // Update the plot with visibility changes
      Plotly.relayout($refs.friendlyHealthPlot, {
        shapes: shapesAndAnnotationsByStep[currentStep]?.filter(item => item.shapes).map(item => item.shapes) || [],
        annotations: shapesAndAnnotationsByStep[currentStep]?.filter(item => item.annotations).map(item => item.annotations) || [],
        ...basePlotStyling()
      });

      // Update previous step
      previousStep = currentStep;
    }
  "
  class="w-full"
>
  <div x-ref="friendlyHealthPlot"></div>
</div>
