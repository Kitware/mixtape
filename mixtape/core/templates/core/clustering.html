<!-- Clustering -->
<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: {text: 'Agent {{title}}'},
      xaxis: {
        ...basePlotLayout.xaxis,
        showticklabels: false,
      },
      yaxis: {
        ...basePlotLayout.yaxis,
        showticklabels: false,
      },
    },
    plot: null,
    shapesAndAnnotationsByStep: {},
    previousStep: null,
  }"
  x-init="
    let eps = '';

    // First create all the trace data and pre-compute shapes
    for (let agent_idx = 0; agent_idx < uniqueAgents.length; agent_idx++) {
      clustering[{{key}}].episode_manifolds.forEach((episode_manifold, episode_idx) => {
        if (episodeIds.length > 1) {
          eps = `episode ${episodeIds[episode_idx]} - `;
        }

        // Create the trace data
        const traceData = {
          x: episode_manifold.map(row => row[agent_idx][0]),
          y: episode_manifold.map(row => row[agent_idx][1]),
          type: 'scatter',
          mode: 'lines',
          colorscale: 'Viridis',
          line: {
            opacity: 1,
            width: 2,
          },
          name: `${eps}${uniqueAgents[agent_idx]}`
        };

        data.push(traceData);

        // Pre-compute shapes for each step in this trace
        for (let step = 0; step < traceData.x.length; step++) {
          if (!shapesAndAnnotationsByStep[step]) {
            shapesAndAnnotationsByStep[step] = [];
          }

          // Create shape for this agent at this step
          const shape = {
            type: 'circle',
            xsizemode: 'pixel',
            ysizemode: 'pixel',
            xanchor: traceData.x[step],
            yanchor: traceData.y[step],
            x0: -12,
            x1: 12,
            y0: -12,
            y1: 12,
            line: {
              width: 2,
              color: 'red',
            },
          };

          // Create annotation for this agent at this step
          const annotation = {
            x: traceData.x[step],
            y: traceData.y[step],
            text: `${eps}${uniqueAgents[agent_idx]}`,
            font: {
              color: $store.categoricalColors[agent_idx % $store.categoricalColors.length],
            },
          };

          shapesAndAnnotationsByStep[step].push({shape, annotation});
        }
      });
    }

    // Add the scatter plot for all episodes
    data.push({
      x: clustering[{{key}}].all_manifolds_x,
      y: clustering[{{key}}].all_manifolds_y,
      type: 'scatter',
      mode: 'markers',
      marker: {
        color: clustering[{{key}}].all_clusters,
        cmin: 0,
        cmax: 9,
        colorscale: 'Viridis',
        size: 20,
        opacity: Array(clustering[{{key}}].all_manifolds_x.length).fill(1)
      },
      name: 'All Episodes'
    });

    previousStep = 0;
    // Initialize the plot with all shapes (only step 0 shapes will be visible)
    plot = Plotly.react($refs.allManifolds, data, {
      ...layout,
      shapes: shapesAndAnnotationsByStep[0].map(({shape}) => shape).filter(Boolean),
      annotations: shapesAndAnnotationsByStep[0].map(({annotation}) => annotation).filter(Boolean),
    }, basePlotConfig);

    $watch('$store.visOptions', () => {
      $nextTick(() => {
        Plotly.relayout(
          $refs.allManifolds,
          {
            autosize: true,
            showlegend: $store.visOptions.visible.includes('plotLegends'),
            legend: legendLayout(),
          })
      });
    });"
  x-effect="
    if (plot) {
      // Update the plot with visibility changes
      Plotly.relayout($refs.allManifolds, {
        shapes: shapesAndAnnotationsByStep[currentStep].map(({shape}) => shape).filter(Boolean),
        annotations: shapesAndAnnotationsByStep[currentStep].map(({annotation}) => annotation).filter(Boolean),
        ...basePlotStyling()
      });

      // Update previous step
      previousStep = currentStep;
    }
  "
>
  <div x-ref="allManifolds"></div>
</div>

<!-- Clustering Timeline -->
<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: {text: 'Agent {{title}} Timeline'},
      height: 150,
      margin: {r: 0, t: 25},
      xaxis: {...basePlotLayout.xaxis},
      yaxis: {...basePlotLayout.yaxis},
    },
    timesteps: Array.from({length: clustering[{{key}}].episode_clusters.length}, (_, i) => i),
    allShapes: {},
    plot: null,
  }"
  x-init="
    data = [
      {
        z: clustering[{{key}}].episode_clusters,
        x: timesteps,
        y: Object.values(uniqueAgents),
        type: 'heatmap',
        showscale: false,
        colorscale: 'Viridis',
      }
    ];
    timesteps.forEach(ts => {
      allShapes[ts] = [{
        type: 'line',
        x0: ts,
        x1: ts,
        y0: 0,
        y1: 1,
        yref: 'paper',
        line: {
          color: 'red',
          width: 2,
          dash: 'dot'
        }
      }]
    });
    layout.shapes = allShapes[0];
    plot = Plotly.react($refs.allClusters, data, layout, basePlotConfig);
    $watch('$store.visOptions', () => {
      $nextTick(() => {
        Plotly.relayout(
          $refs.allClusters, {
            autosize: true,
            showlegend: $store.visOptions.visible.includes('plotLegends'),
            legend: legendLayout(),
          })
      });
    });"
  x-effect="
    if (plot) {
      Plotly.relayout($refs.allClusters, {
        shapes: allShapes[currentStep],
        ...basePlotStyling(),
      });
    }"
>
  <div x-ref="allClusters"></div>
</div>
