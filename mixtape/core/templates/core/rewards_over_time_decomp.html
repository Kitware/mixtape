<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: {text: 'Rewards Over Time (Decomposed)'},
      xaxis: { ...basePlotLayout.xaxis, title: {text: 'Time Step'} },
      yaxis: { ...basePlotLayout.yaxis, title: {text: 'Cumulative Reward'} },
      shapes: [],
    },
    plot: null,
    initPlot() {
      // Plot decomposed rewards for each episode
      let eps = '';
      decomposedRewards.forEach((episodeRewards, episodeIdx) => {
        if (episodeIds.length > 1) {
          eps = `Episode ${episodeIds[episodeIdx]}`;
        }
        Object.keys(episodeRewards).forEach((rewardType, rewardIdx) => {
          const rewardData = episodeRewards[rewardType];
          this.data.push({
            x: Array.from({length: rewardData.length}, (_, i) => i),
            y: rewardData,
            type: 'scatter',
            mode: 'lines',
            name: `${eps} - ${rewardType}`,
          });
        });
      });

      // Calculate overall min and max Y values from all data
      const allYValues = decomposedRewards.flatMap(episodeRewards =>
        Object.values(episodeRewards).flatMap(rewardData => rewardData)
      );

      // Add current step indicator as a shape
      this.layout.shapes = this.createShapes(allYValues);

      // Add annotations for current step values
      this.layout.annotations = this.createAnnotations();

      this.plot = Plotly.newPlot($refs.rewardsOverTime, this.data, this.layout, basePlotConfig);
    },
    createShapes(allYValues) {
      const maxY = Math.max(...allYValues);
      const minY = Math.min(...allYValues);

      return [{
        type: 'line',
        x0: currentStep,
        x1: currentStep,
        y0: minY,
        y1: maxY,
        line: {
          color: 'red',
          width: 2,
          dash: 'dot'
        }
      }];
    },
    createAnnotations() {
      const episodeCount = Object.keys(decomposedRewards).length;
      const annotations = decomposedRewards.flatMap((episodeRewards, episodeIdx) => {
        const componentCount = Object.keys(episodeRewards).length;
        const offset = 40 / (componentCount * episodeCount);
        return Object.entries(episodeRewards).map(([rewardType, rewardData]) => {
          const currentValue = rewardData[currentStep];
          return {
            x: currentStep,
            y: currentValue,
            text: currentValue.toFixed(2),
            showarrow: true,
            arrowhead: 2,
            arrowsize: 1,
            arrowwidth: 2,
            ax: 20,
            ay: -20,
            font: {
              size: 10
            }
          };
        })
      });
      return annotations;
    },
    updateCurrentStep() {
      if (this.plot) {
        // Calculate overall min and max Y values from all data
        let allYValues = [];
        // Get all Y values from decomposed rewards
        decomposedRewards.forEach(episodeRewards => {
          Object.values(episodeRewards).forEach(rewardData => {
            allYValues = allYValues.concat(rewardData);
          });
        });

        Plotly.relayout($refs.rewardsOverTime, {
          shapes: this.createShapes(allYValues),
          annotations: this.createAnnotations(),
          ...basePlotStyling(),
        });
      }
    }
  }"
  x-init="initPlot();
  $watch('$store.visOptions', () => {
    $nextTick(() => {
      Plotly.relayout(
        $refs.rewardsOverTime,
        {
          autosize: true,
          showlegend: $store.visOptions.visible.includes('plotLegends'),
          legend: legendLayout(),
        })
    });
  });"
  x-effect="updateCurrentStep()"
>
  <div x-ref="rewardsOverTime"></div>
</div>
