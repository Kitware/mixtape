<div
  x-data="{
    data: [],
    layout: {
      ...basePlotLayout,
      title: {text: 'Rewards Over Time (Decomposed)'},
      xaxis: { ...basePlotLayout.xaxis, title: {text: 'Time Step'} },
      yaxis: { ...basePlotLayout.yaxis, title: {text: 'Cumulative Reward'} },
    },
    plot: null,
    shapesAndAnnotationsByStep: {},
    previousStep: 0,
    allYValues: [],
    initPlot() {
      // Plot decomposed rewards for each episode
      let eps = '';
      decomposedRewards.forEach((episodeRewards, episodeIdx) => {
        if (episodeIds.length > 1) {
          eps = `episode ${episodeIds[episodeIdx]}`;
        }
        Object.keys(episodeRewards).forEach((rewardType, rewardIdx) => {
          const rewardData = episodeRewards[rewardType];
          this.data.push({
            x: Array.from({length: rewardData.length}, (_, i) => i),
            y: rewardData,
            type: 'scatter',
            mode: 'lines',
            name: `${eps} - ${rewardType}`,
          });
        });
      });

      // Calculate overall min and max Y values from all data
      this.allYValues = decomposedRewards.flatMap(episodeRewards =>
        Object.values(episodeRewards).flatMap(rewardData => rewardData)
      );

      const maxY = Math.max(...this.allYValues);
      const minY = Math.min(...this.allYValues);

      // Create all steps and annotations at once
      const timeSteps = Array.from({length: maxSteps}, (_, i) => i);
      timeSteps.forEach((ts) => {
        if (!this.shapesAndAnnotationsByStep[ts]) {
          this.shapesAndAnnotationsByStep[ts] = [];
        }

        // Add vertical line shape for this step
        this.shapesAndAnnotationsByStep[ts].push({
          shape: {
            type: 'line',
            x0: ts,
            x1: ts,
            y0: minY,
            y1: maxY,
            line: {
              color: 'red',
              width: 2,
              dash: 'dot'
            },
          }
        });

        // Add annotations for each reward type at this step
        decomposedRewards.forEach((episodeRewards, episodeIdx) => {
          Object.entries(episodeRewards).forEach(([rewardType, rewardData], rewardIdx) => {
            if (ts < rewardData.length) {
              this.shapesAndAnnotationsByStep[ts].push({
                annotation: {
                  x: ts,
                  y: rewardData[ts],
                  text: rewardData[ts].toFixed(2),
                  bgcolor: 'rgba(0, 0, 0, 0.5)',
                  arrowcolor: $store.categoricalColors[(episodeIdx * Object.keys(episodeRewards).length + rewardIdx) % $store.categoricalColors.length],
                  font: {
                    size: 10,
                    color: $store.categoricalColors[(episodeIdx * Object.keys(episodeRewards).length + rewardIdx) % $store.categoricalColors.length]
                  },
                }
              });
            }
          });
        });
      });

      this.plot = Plotly.react($refs.rewardsOverTime, this.data, {
        ...this.layout,
        shapes: this.shapesAndAnnotationsByStep[0].map(({shape}) => shape).filter(Boolean),
        annotations: this.shapesAndAnnotationsByStep[0].map(({annotation}) => annotation).filter(Boolean),
      }, basePlotConfig);
    }
  }"
  x-init="initPlot();
  $watch('$store.visOptions', () => {
    $nextTick(() => {
      Plotly.relayout(
        $refs.rewardsOverTime,
        {
          autosize: true,
          showlegend: $store.visOptions.visible.includes('plotLegends'),
          legend: legendLayout(),
        })
    });
  });"
  x-effect="
    if (plot) {
      // Update the plot with visibility changes
      Plotly.relayout($refs.rewardsOverTime, {
        shapes: shapesAndAnnotationsByStep[currentStep].map(({shape}) => shape).filter(Boolean),
        annotations: shapesAndAnnotationsByStep[currentStep].map(({annotation}) => annotation).filter(Boolean),
        ...basePlotStyling()
      });

      // Update previous step
      previousStep = currentStep;
    }
  "
>
  <div x-ref="rewardsOverTime"></div>
</div>
